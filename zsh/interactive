#!/bin/zsh

# zinit
export ZINIT_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"
if [[ ! -d "$ZINIT_HOME" ]]; then
    ZINIT_HOME="$(dirname "$ZINIT_HOME")" \
    NO_EMOJI=1 \
    NO_INPUT=1 \
    NO_TUTORIAL=1 \
    NO_ANNEXES=1 \
    NO_EDIT=1 \
    sh -c "$(curl -fsSL https://git.io/zinit-install)"
fi

source "$ZINIT_HOME/zinit.zsh"

# powerlevel10k theme
zinit ice depth=1
zinit light romkatv/powerlevel10k

# Enable completion
autoload -Uz compinit
compinit

# force 256-color mode when inside containers
if [ -d /boot ] && [ -n "$(find /boot -maxdepth 0 -empty)" ]; then
  export TERM=screen-256color
fi

# ls aliases
alias ls="ls --color=auto"
alias ll="ls -lh"
alias la="ls -a"
alias lla="ll -a"

# color aliases
alias diff="diff --color=auto"
alias grep="grep --color=auto"
alias ip="ip --color=auto"
alias dmesg="dmesg --color=auto"

# eza
if [[ $commands[eza] ]]; then
    alias ls=eza
    alias lt='ll --tree'
fi

# bat
if [[ $commands[bat] ]]; then
    export BAT_STYLE="snip"
    export BAT_THEME="base16"
    export BAT_THEME_DARK="base16"
    export BAT_THEME_LIGHT="base16"
    alias cat=bat
fi

# zoxide
if [[ $commands[zoxide] ]]; then
    source <(zoxide init zsh)
fi

# neovim
if [[ $commands[nvim] ]]; then
    export EDITOR=nvim
elif [[ $commands[vim] ]]; then
    export EDITOR=vim
fi

# kubectl
if [[ $commands[kubectl] ]]; then
    source <(kubectl completion zsh)
fi

if [[ -f $HOME/.kube/config ]]; then
    export KUBECONFIG=$HOME/.kube/config
fi

# Enable automatic activation of virtualenvs
if [[ $commands[pyenv] ]]; then
    source <(pyenv init --path)
    source <(pyenv init -)
    source <(pyenv virtualenv-init -)
fi

# keybindings
source "$ZDOTDIR/keybindings"

# less
export LESS=" \
    --quit-if-one-screen \
    --ignore-case \
    --status-column \
    --LONG-PROMPT \
    --RAW-CONTROL-CHARS \
    --HILITE-UNREAD \
    --tabs=4 \
    --no-init \
    --window=-4 \
"
# a couple of keybindings and color config for less
# requires a fairly recent version of less
export LESSKEYIN="$HOME/.dotfiles/.lesskey"

# fzf
if [[ $commands[fzf] ]]; then
    # calculate fzf preview window params based on terminal size
    preview_params() {
        # sets fzf preview position and status (no/hidden) depending on terminal size
        local hide_threshold_columns=74
        local hide_threshold_lines=36
        local lines_factor=2.3 # assume that a cell is n times a tall as it wide

        local config="default"
        local hidden="nohidden"

        if ((COLUMNS > LINES * lines_factor)); then   # screen is wider than it is tall
            config="right,50%,border-left"

            # force hide the preview window if the screen is not wide enough
            if ((COLUMNS < hide_threshold_columns)); then
                hidden="hidden"
            fi
        else # screen is taller than it is wide
            config="bottom,50%,border-top"

            # force hide the preview window if the screen is not tall enough
            if ((LINES < hide_threshold_lines)); then
                hidden="hidden"
            fi
        fi

        echo "$config,$hidden"
    }

    set_fzf_opts() {
        preview_window=$(preview_params)
        export FZF_DEFAULT_OPTS="
            --ansi
            --cycle
            --reverse
            --info=inline-right
            --no-separator
            --height=30%
            --border=none
            --list-border=none
            --input-border=none
            --preview='preview {}'
            --pointer=î­°
            --highlight-line
            --color=gutter:-1,pointer:255,scrollbar:4,preview-scrollbar:4
            --bind='ctrl-space:toggle-down'
            --bind='ctrl-z:toggle-preview'
            --bind='ctrl-y:execute-silent(printf '%s' {+} | zsh -ic to-clip)'
            --bind='ctrl-u:preview-up+preview-up+preview-up+preview-up+preview-up'
            --bind='ctrl-d:preview-down+preview-down+preview-down+preview-down+preview-down'
            --bind='ctrl-r:toggle-all'
            --bind='ctrl-s:toggle-sort'
            --bind='ctrl-w:toggle-preview-wrap'
            --bind='home:first'
            --bind='end:last'
            --preview-window=$preview_window
        "
        export FZF_CTRL_T_OPTS="--no-height --no-border --preview-window=$preview_window"
        export FZF_ALT_C_OPTS="--no-height --no-border --preview-window=$preview_window"
    }

    export FZF_DEFAULT_COMMAND="fd --type f --type l --color=never --no-ignore-vcs --hidden"
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    export FZF_ALT_C_COMMAND="fd --type d --color=never --no-ignore-vcs --hidden"

    __fzf-complete() {
        local trigger=${FZF_COMPLETION_TRIGGER:-**}
        LBUFFER="${LBUFFER}${trigger}"
        zle fzf-completion 2>/dev/null || zle expand-or-complete
        if [[ $LBUFFER == *$trigger ]]; then
            LBUFFER=${LBUFFER%$trigger}
        fi
    }
    zle -N __fzf-complete
    bindkey "^F" __fzf-complete

    trap set_fzf_opts SIGWINCH # call whenever the terminal resizes
    set_fzf_opts

    source <(fzf --zsh)

    # Override fzf's version by this one that only uses the ~/.ssh/config file
    _my_ssh_completion() {
        local -a hosts
        hosts=($(cat ~/.ssh/config | grep -E '^Host\s+' | awk '{print $2}'))
        compadd -a hosts
    }
    compdef _my_ssh_completion ssh ssht

    # fzf-tab
    load_fzf_tab() {
        # set list-colors to enable filename colorizing
        zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
        # force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
        zstyle ':completion:*' menu no

        # Fzf settings
        zstyle ':fzf-tab:*' use-fzf-default-opts yes
        zstyle ':fzf-tab:complete:*' fzf-flags --preview-window=right:50%,hidden
        zstyle ':fzf-tab:complete:*' fzf-preview 'preview $realpath'

        # set descriptions format to enable group support
        # NOTE: don't use escape sequences (like '%F{red}%d%f') here, fzf-tab will ignore them
        zstyle ':completion:*:descriptions' format '[%d]'
        # switch group using `<` and `>`
        zstyle ':fzf-tab:*' switch-group '<' '>'

        # Disable sorting for ssh and git checkout
        zstyle ':completion:*:(ssh|ssht|git-checkout):*' sort false

        # Kill
        zstyle ':completion:*:*:*:*:processes' command "ps -u $USER -o pid,user,comm -w -w"
        zstyle ':fzf-tab:complete:(kill|ps):argument-rest' fzf-preview \
            '[[ $group == "[process ID]" ]] && ps -p $word -o command= -w -w'
        zstyle ':fzf-tab:complete:(kill|ps):argument-rest' fzf-flags --preview-window=down:3:wrap

        zstyle ':fzf-tab:complete:(systemctl-*|journal-ctl-*):*' fzf-preview \
            'SYSTEMD_COLORS=1 systemctl status $word'

        # Git
        zstyle ':fzf-tab:complete:git-(add|diff|restore):*' fzf-preview \
            'git diff $word | delta'
        zstyle ':fzf-tab:complete:git-log:*' fzf-preview \
            'git log --color=always $word'
        zstyle ':fzf-tab:complete:git-help:*' fzf-preview \
            'git help $word | bat -plman --color=always'
        zstyle ':fzf-tab:complete:git-show:*' fzf-preview \
            'case "$group" in
            "commit tag") git show --color=always $word ;;
            *) git show --color=always $word | delta ;;
            esac'
        zstyle ':fzf-tab:complete:git-checkout:*' fzf-preview \
            'case "$group" in
            "modified file") git diff $word | delta ;;
            "recent commit object name") git show --color=always $word | delta ;;
            *) git log --color=always $word ;;
            esac'

        # Homebrew
        zstyle ':fzf-tab:complete:brew-(install|uninstall|search|info):*-argument-rest' fzf-preview \
            'brew info $word'
    }
    zinit ice lucid depth=1 atload=load_fzf_tab
    zinit light Aloxaf/fzf-tab

    # forgit
    init_forgit() {
        export FORGIT_NO_ALIASES=1

        set_fzf_opts() {
            export FORGIT_FZF_DEFAULT_OPTS="--preview-window=$(preview_params)"
        }

        trap set_fzf_opts SIGWINCH # call whenever the terminal resizes
        set_fzf_opts
    }
    zinit ice wait=0 lucid depth=1 atload='path=($PWD/bin $path)' atinit=init_forgit
    zinit light wfxr/forgit
fi

# fast syntax highlighting
load_fsh() {
    FAST_HIGHLIGHT[git-cmsg-len]=60
}
zinit ice wait=!0 lucid depth=1 atload=load_fsh
zinit light zdharma-continuum/fast-syntax-highlighting

# fish-like abbreviations, aliases that auto-expand when pressing space
init_abbr() {
    ABBR_USER_ABBREVIATIONS_FILE="$ZDOTDIR/abbreviations"
    ABBR_AUTOLOAD=0
    ABBR_DEFAULT_BINDINGS=0
    ABBR_SET_EXPANSION_CURSOR=1
    ABBR_SET_LINE_CURSOR=1
    ABBR_REGULAR_ABBREVIATION_SCALAR_PREFIXES+=( "sudo " )
    ABBR_REGULAR_ABBREVIATION_GLOB_PREFIXES+=( "(*\|| )" )
}

load_abbr() {
    bindkey "^ " magic-space # ctrl+space to insert space without expanding abbr
    bindkey -M isearch " " magic-space # normal space is normal in incremental search

    _abbr_expand_and_insert() {
        emulate -LR zsh

        abbr-expand-and-insert
        zle redisplay  # Refresh required to update syntax highlighting
    }
    zle -N _abbr_expand_and_insert
    bindkey " " _abbr_expand_and_insert # space to expand abbr
    bindkey -M isearch "^ " _abbr_expand_and_insert # ctrl+space expands abbr in isearch

    # Allows abbreviation to be expanded on enter if they're the only command to execute
    _abbr_expand_and_accept() {
        emulate -LR zsh

        # make sure the rbuffer doesn't start with a space
        if [[ ! "$RBUFFER" || "$RBUFFER" =~ ^[[:space:]].+ ]]; then
            abbr-expand-and-accept
        else
            zle accept-line
        fi
    }
    zle -N _abbr_expand_and_accept
    bindkey "^M" _abbr_expand_and_accept

    # syntax highlighting for abbreviations
    chroma_single_word() {
        (( next_word = 2 | 8192 ))

        local __first_call="$1" __wrd="$2" __start_pos="$3" __end_pos="$4"
        local __style

        (( __first_call )) && { __style=${FAST_THEME_NAME}alias }
        [[ -n "$__style" ]] && (( __start=__start_pos-${#PREBUFFER}, __end=__end_pos-${#PREBUFFER}, __start >= 0 )) && reply+=("$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}")

        (( this_word = next_word ))
        _start_pos=$_end_pos

        return 0
    }

    register_single_word_chroma() {
        local word=$1
        if [[ -x $(command -v $word) ]] || [[ -n $FAST_HIGHLIGHT["chroma-$word"] ]]; then
            return 1
        fi

        FAST_HIGHLIGHT+=( "chroma-$word" chroma_single_word )
        return 0
    }

    if [[ -n $FAST_HIGHLIGHT ]]; then
        for abbr in ${(f)"$(abbr list-abbreviations)"}; do
            if [[ $abbr != *' '* ]]; then
                register_single_word_chroma ${(Q)abbr}
            fi
        done
    fi
}

zinit ice wait=0 lucid depth=1 atinit=init_abbr atload=load_abbr submods
zinit light olets/zsh-abbr

# fish like substring search
init_substring_search() {
    HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND=underline
    HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_NOT_FOUND=fg=8,underline
    HISTORY_SUBSTRING_SEARCH_FUZZY=1
    bindkey '^[[A' history-substring-search-up # up
    bindkey '^[OA' history-substring-search-up
    bindkey '^[[B' history-substring-search-down # down
    bindkey '^[OB' history-substring-search-down
}
zinit ice wait=0 lucid depth=1 atinit=init_substring_search
zinit light zsh-users/zsh-history-substring-search
